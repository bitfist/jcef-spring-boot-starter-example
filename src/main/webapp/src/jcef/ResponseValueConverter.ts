/** AUTO-GENERATED by JCEF TypeScriptObjectProcessor â€“ DO NOT EDIT **/
import type {ResponseType} from "./ResponseType";

export class ResponseValueConverter {
    static convert<T>(payload: any, responseType: ResponseType) : any {
        const lower = payload.toLowerCase();

        const parseBoolean = () => (lower === 'true') as unknown as T;
        const parseNumber  = () => Number(payload) as unknown as T;
        const parseObject  = () => JSON.parse(payload) as T;
        const parseString  = () => payload as unknown as T;

        let result: T;
        try {
            switch (responseType) {
                case 'boolean':
                    result = parseBoolean();
                    break;

                case 'number':
                    result = parseNumber();
                    break;

                case 'object':
                    result = parseObject();
                    break;

                case 'string':
                    result = parseString();
                    break;

                case 'auto':
                default:
                    // auto-detect logic
                    if (lower === 'true' || lower === 'false') {
                        result = parseBoolean();
                    } else if (!Number.isNaN(Number(payload)) && String(Number(payload)) === payload) {
                        result = parseNumber();
                    } else if (payload.startsWith('{') || payload.startsWith('[')) {
                        try {
                            const parsed = JSON.parse(payload);
                            if (parsed !== null && typeof parsed === 'object') {
                                result = parsed as T;
                                break;
                            }
                        } catch {
                            // fall through to string
                        }
                        result = parseString();
                    } else {
                        result = parseString();
                    }
                    break;
            }
        } catch {
            // on any parsing error, fallback to raw string
            result = parseString();
        }

        return result;
    }
}